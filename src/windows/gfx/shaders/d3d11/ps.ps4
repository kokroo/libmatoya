// Copyright (c) Christopher D. Dickson <cdd@matoya.group>
//
// This Source Code Form is subject to the terms of the MIT License.
// If a copy of the MIT License was not distributed with this file,
// You can obtain one at https://spdx.org/licenses/MIT.html.

#include "hdr10.hlsl"

struct VS_OUTPUT {
	float4 position : SV_POSITION;
	float2 texcoord : TEXCOORD;
};

cbuffer VS_CONSTANT_BUFFER : register(b0) {
	float width;
	float height;
	float vp_height;
	float pad0;
	uint4 effects;
	float4 levels;
	uint planes;
	uint rotation;
	uint conversion;
	uint hdr;
	uint diffmode;
	float diffbrighten;
};

SamplerState ss {
};

Texture2D tex0 : register(t0);
Texture2D tex1 : register(t1);
Texture2D tex2 : register(t2);
Texture2D texdiffrgba : register(t3);
Texture2D texdiffrgb10a2 : register(t4);

inline float4 yuv_to_rgba(uint conversion, uint hdr, float y, float u, float v)
{
	// 10-bit -> 16-bit
	if (conversion & 0x4) {
		y *= 64.0;
		u *= 64.0;
		v *= 64.0;
	}

	// Full range
	if (conversion & 0x1) {
		// 10-bit
		if (conversion & 0x2) {
			u -= (512.0 / 1023.0);
			v -= (512.0 / 1023.0);

		} else {
			u -= (128.0 / 255.0);
			v -= (128.0 / 255.0);
		}

	// Limited
	} else {
		// 10-bit
		if (conversion & 0x2) {
			y = (y - 64.0 / 1023.0) * (1023.0 / 876.0);
			u = (u - 512.0 / 1023.0) * (1023.0 / 896.0);
			v = (v - 512.0 / 1023.0) * (1023.0 / 896.0);

		} else {
			y = (y - 16.0 / 255.0) * (255.0 / 219.0);
			u = (u - 128.0 / 255.0) * (255.0 / 224.0);
			v = (v - 128.0 / 255.0) * (255.0 / 224.0);
		}
	}

	// TODO: Yo......what if we did 10-bit YCgCo for SDR instead of YCbCr????? Would that improve color accuracy????? Let's try it out!!!

	float kr = hdr ? 0.2627 : 0.2126;
	float kb = hdr ? 0.0593 : 0.0722;

	float r = y + (2.0 - 2.0 * kr) * v;
	float b = y + (2.0 - 2.0 * kb) * u;
	float g = (y - kr * r - kb * b) / (1.0 - kr - kb);

	return float4(r, g, b, 1.0);
}

inline float4 sample_rgba(uint planes, uint conversion, uint hdr, float2 uv)
{
	float4 pixel0 = tex0.Sample(ss, uv);

	if (planes == 2) {
		float4 pixel1 = tex1.Sample(ss, uv);
		float y = pixel0.r;
		float u = pixel1.r;
		float v = pixel1.g;

		return yuv_to_rgba(conversion, hdr, y, u, v);

	} else if (planes == 3) {
		float y = pixel0.r;
		float u = tex1.Sample(ss, uv).r;
		float v = tex2.Sample(ss, uv).r;

		return yuv_to_rgba(conversion, hdr, y, u, v);

	} else if (conversion & 0x8) {
		// AYUV
		float y = pixel0.r;
		float u = pixel0.g;
		float v = pixel0.b;

		// Y410
		if (conversion & 0x2) {
			y = pixel0.g;
			u = pixel0.r;
		}

		return yuv_to_rgba(conversion, hdr, y, u, v);

	} else {
		return pixel0;
	}
}

inline void sharpen(float w, float h, float level, inout float2 uv)
{
	float2 res = float2(w, h);
	float2 p = uv * res;
	float2 c = floor(p) + 0.5;
	float2 dist = p - c;

	if (level >= 0.5) {
		dist = 16.0 * dist * dist * dist * dist * dist;

	} else {
		dist = 4.0 * dist * dist * dist;
	}

	uv = (c + dist) / res;
}

inline void scanline(float y, float h, float level, inout float4 rgba)
{
	float n = floor(h / 240.0);

	if (fmod(floor(y * h), n) < n / 2.0)
		rgba *= level;
}

inline float2 rotate(uint rotation, float2 texcoord)
{
	float2 uv = texcoord;

	// Rotation
	if (rotation == 1 || rotation == 3) {
		float tmp = uv[0];
		uv[0] = uv[1];
		uv[1] = tmp;
	}

	// Flipped vertically
	if (rotation == 1 || rotation == 2)
		uv[1] = 1.0 - uv[1];

	// Flipped horizontally
	if (rotation == 2 || rotation == 3)
		uv[0] = 1.0 - uv[0];

	return uv;
}

float lab_lightness(const float x)
{
	const float epsilon = 216.0f / 24389.0f;
	const float kappa = 24389.0f / 27.0f / 116.0f;

	return x > epsilon ? sign(x) * pow(abs(x), 1.0f / 3.0f) : (kappa * x + 16.0f / 116.0f);
}

float3 rgb_to_lab(const float3 rgb, const float3x3 rgb_to_xyz, const float3 xyz_white)
{
	// Courtesy of Bruce Lindbloom	

	// RGB to XYZ
	// http://brucelindbloom.com/Eqn_RGB_to_XYZ.html
	const float3 xyz = mul(rgb_to_xyz, rgb);

	// XYZ to Lab	
	// http://brucelindbloom.com/Eqn_XYZ_to_Lab.html
	const float3 r = rgb / xyz_white;
	const float3 f = float3(
		lab_lightness(r.x),
		lab_lightness(r.y),
		lab_lightness(r.z)
	);
	return float3(
		116.0f * f.y - 16.0f,
		500.0f * (f.x - f.y),
		200.0f * (f.y - f.z)
	);
}

inline float deg2rad(float deg)
{
	return deg * 3.14159f / 180.0f;
}

inline float rad2deg(float rad)
{
	return rad * 180.0f / 3.14159f;
}

float deltaE_2000(const float3 rgb_A, const float3 rgb_B, const float3x3 rgb_to_xyz, const float3 xyz_white)
{
	float3 lab_A = rgb_to_lab(rgb_A, rgb_to_xyz, xyz_white);
	float3 lab_B = rgb_to_lab(rgb_B, rgb_to_xyz, xyz_white);

	// Courtesy of http://brucelindbloom.com/index.html?Eqn_DeltaE_CIE2000.html

	const float L_1 = lab_A.x;
	const float a_1 = lab_A.y;
	const float b_1 = lab_A.z;
	const float L_2 = lab_B.x;
	const float a_2 = lab_B.y;
	const float b_2 = lab_B.z;

	// These  K_* constants are always 1 for computer displays
	const float K_L = 1.0f;
	const float K_C = 1.0f;
	const float K_H = 1.0f;

	const float C_1 = sqrt(a_1 * a_1 + b_1 * b_1);
	const float C_2 = sqrt(a_2 * a_2 + b_2 * b_2);
	const float C_bar = 0.5f * (C_1 + C_2);

	const float C_bar_pow7 = pow(C_bar, 7);
	const float G = 0.5f * (1.0f - sqrt(C_bar_pow7 / (C_bar_pow7 + pow(25, 7))));

	const float a_1_prime = a_1 * (1.0f + G);
	const float a_2_prime = a_2 * (1.0f + G);
	const float C_1_prime = sqrt(a_1_prime * a_1_prime + b_1 * b_1);
	const float C_2_prime = sqrt(a_2_prime * a_2_prime + b_2 * b_2);
	const float C_bar_prime = 0.5f * (C_1_prime + C_2_prime);

	float h_1_prime = rad2deg(atan2(b_1, a_1_prime));
	if (h_1_prime < 0)
		h_1_prime += 360.0f;
	float h_2_prime = rad2deg(atan2(b_2, a_2_prime));
	if (h_2_prime < 0)
		h_2_prime += 360.0f;
	const float H_bar_prime = abs(h_1_prime - h_2_prime) > 180.0f ?
		(0.5f * (h_1_prime + h_2_prime + 360.0f)) :
		(0.5f * (h_1_prime + h_2_prime));

	const float T = 1.0f -
		(0.17f * cos(deg2rad(H_bar_prime - 30))) +
		(0.24f * cos(deg2rad(2 * H_bar_prime))) +
		(0.32f * cos(deg2rad(3 * H_bar_prime + 6))) -
		(0.20f * cos(deg2rad(4 * H_bar_prime - 63)));

	const float L_bar_prime = 0.5f * (L_1 + L_2);
	const float minus50sq = (L_bar_prime - 50.0f) * (L_bar_prime - 50.0f);

	const float S_L = 1.0f + (0.015f * minus50sq / sqrt(20.0f + minus50sq));
	const float S_C = 1.0f + 0.045f * C_bar_prime;
	const float S_H = 1.0f + 0.015f * C_bar_prime * T;

	const float C_bar_prime_pow7 = pow(C_bar_prime, 7);
	const float R_C = 2.0f * sqrt(C_bar_prime_pow7 / (C_bar_prime_pow7 + pow(25, 7)));
	const float delta_theta = 30.0f * exp(-pow(H_bar_prime - 275.0f / 25.0f, 2));
	const float R_T = -R_C * sin(deg2rad(2.0f * delta_theta));

	const float dt_h_prime = h_2_prime - h_1_prime;
	const float abs_dt_h_prime = abs(dt_h_prime);
	const float delta_h_prime = abs_dt_h_prime <= 180.0f ? dt_h_prime : abs_dt_h_prime > 180.0f && h_2_prime <= h_1_prime ? dt_h_prime + 360.0f : dt_h_prime - 360.0f;

	const float delta_L_prime = L_2 - L_1;
	const float delta_C_prime = C_2_prime - C_1_prime;
	const float delta_H_prime = 2.0f * sqrt(C_1_prime * C_2_prime) * sin(deg2rad(delta_h_prime * 0.5f));

	const float final_term_1 = delta_L_prime / (K_L * S_L);
	const float final_term_2 = delta_C_prime / (K_C * S_C);
	const float final_term_3 = delta_H_prime / (K_H * S_H);
	const float final_term_4 = R_T * final_term_2 * final_term_3;

	const float delta_E = sqrt(final_term_1 * final_term_1 + final_term_2 * final_term_2 + final_term_3 * final_term_3 + final_term_4);
	return delta_E;
}

float deltaE_ITP(const float3 rgb_A, const float3 rgb_B)
{
	// Courtesy of the official BT.2124 spec: https://www.itu.int/dms_pubrec/itu-r/rec/bt/R-REC-BT.2124-0-201901-I!!PDF-E.pdf

	const float3 ictcp_A = rec2020_linear_to_ictcp(rgb_A);
	const float3 ictcp_B = rec2020_linear_to_ictcp(rgb_B);

	const float3 itp_A = ictcp_A * float3(1.0f, 0.5f, 1.0f);
	const float3 itp_B = ictcp_B * float3(1.0f, 0.5f, 1.0f);

	const float dt_I = itp_A[0] - itp_B[0];
	const float dt_T = itp_A[1] - itp_B[1];
	const float dt_P = itp_A[2] - itp_B[2];

	const float delta_E = 720.0f * sqrt(dt_I * dt_I + dt_T * dt_T + dt_P * dt_P);
	return delta_E;
}

// Thanks to colour.py module for these constants
static const float3x3 REC709_TO_XYZ =
{
	{0.4124,  0.3576,  0.1805},
	{0.2126,  0.7152,  0.0722},
	{0.0193,  0.1192,  0.9505}
};

// Thanks to colour.py module for these constants
static const float3x3 REC2020_TO_XYZ =
{
	{0.63696,  0.14462,  0.16889},
	{0.26270,  0.677998, 0.59302},
	{0.49941,  0.28073,  0.106098}
};

// Thanks to https://www.mathworks.com/help/images/ref/whitepoint.html
static const float3 D65_WHITE = {0.95047, 1, 1.08883};

float4 main(VS_OUTPUT input) : SV_TARGET
{
	// Rotate
	float2 uv = rotate(rotation, input.texcoord);

	// Sharpen
	for (uint x = 0; x < 2; x++)
		if (effects[x] == 2)
			sharpen(width, height, levels[x], uv);

	// Sample
	float4 rgba = sample_rgba(planes, conversion, hdr, uv);

	// Compare sample with a diff texture
	if (diffmode) {

		float4 rgba_diff = 0;

		if (hdr) {
			rgba_diff = texdiffrgb10a2.Sample(ss, uv);
		} else {
			rgba_diff = texdiffrgba.Sample(ss, uv);

			if (conversion & 0x2) // 10-bit SDR
				// Final output is normed 8-bit but the decoded frame is normed 10-bit, so we re-normalize
				rgba = round(rgba * 255.0f) / 255.0f;
		}

		if (diffmode == 1) {
			rgba = abs(rgba - rgba_diff);
			rgba *= diffbrighten; // brighten so the diff is stark

		} else if (diffmode == 2) {
			float3 actual = hdr ? rgba.rgb : rgba.rgb;
			float3 diff = hdr ? rgba_diff.rgb : rgba_diff.rgb;

			float de = hdr ? deltaE_ITP(actual, diff) : deltaE_2000(
				actual,
				diff, 
				hdr ? REC2020_TO_XYZ : REC709_TO_XYZ,
				D65_WHITE
			); 
			
			if (de >= 2.0f) { // unacceptable - show as bright red
				rgba = float4(1, 0, 0, 1);

			} else if (de >= 1.0f) { // mediocre - lerp from red to yellow
				rgba = float4(1, lerp(1, 0, de - 1.0f), 0, 1);

			} else if (de >= 0.5f) { // satisfactory - lerp from yellow to green
				rgba = float4(lerp(0, 1, (de - 0.5f) * 2.0f), 1, 0, 1);

			} else { // great/perfect - lerp from green to black
				rgba = float4(0, lerp(0, 1, de * 2.0f), 0, 1);
			}

		} else {
			rgba = rgba_diff;
		}
	}

	// Effects
	for (uint y = 0; y < 2; y++)
		if (effects[y] == 1)
			scanline(input.texcoord.y, vp_height, levels[y], rgba);

	return rgba;
}
